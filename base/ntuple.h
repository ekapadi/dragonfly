#if !defined(__ntuple__h)
#define __ntuple__h

/* *********************************************************************** */
/*                                                                         */
/* Copyright (C) 2010  Kort Travis                                         */
/*                                                                         */
/*                                                                         */
/* This program is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU Lesser General Public License as          */
/* published by the Free Software Foundation; version 2.1 of the License.  */
/*                                                                         */
/* This program is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of          */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
/* GNU Lesser General Public License for more details.                     */
/*                                                                         */
/* You should have received a copy of the GNU Lesser General Public        */
/* License along with this program; if not, write to the Free Software     */
/* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,  */
/* USA.                                                                    */
/*                                                                         */
/* *********************************************************************** */


namespace linalg{

// most of the following are required in order to move "ntuple" to "namespace linalg":
using number::epsilon;
using number::zero;
using number::one;
using number::pi;
using number::integer;
using number::ratio;
using number::conv;
using number::numberTraits;
    
template <class T, size_t DIM=3>
class ntuple{
  private:

	  T v_[DIM];

  public:
	  typedef typename numberTraits<T>::magnitudeType R;    
    typedef ntuple this_type;
    typedef T value_type; 
    typedef T* iterator;
    typedef const T* const_iterator;


    inline T& operator[](size_t n);

    inline const T& operator[](size_t n)const;		

    // allow use with STL iterator methods (and other STL-style interface methods):
		inline T* begin();
		
		inline const T* begin()const;
		
		inline T* end();
		
		inline const T* end()const;
		
    inline size_t size(void)const;
    
    inline void resize(size_t);
    
						
	  R dist(const ntuple& other)const;

    // inner product
	  T operator*(const ntuple& other)const;

    // magnitude
		inline R abs(void)const;
		
		R absSqr(void)const;

    // number of elements with magnitude > eps:
    size_t numberNonzeroElements(const R& eps=epsilon<R>())const;

    // number of elements with magnitude > eps (short name):
    size_t nnz(const R& eps=epsilon<R>())const;

    // bit-mask corresponding to non-zero elements:
		size_t mask_nz(void)const;
				
    void normalize(void);

    void invert(bool spherical=false);

    void clear(void);
		
    inline bool operator==(const ntuple<T,DIM>& other)const;
    
    inline bool operator!=(const ntuple<T,DIM>& other)const;
    		
    inline ntuple<T,DIM>& operator+(void); 
		
		inline ntuple<T,DIM> operator-(void)const; 
							
    inline ntuple<T,DIM> operator+(const ntuple<T,DIM>& other)const;

    inline ntuple<T,DIM> operator-(const ntuple<T,DIM>& other)const;
		
    inline ntuple<T,DIM> operator*(const T& r)const;
				
    inline ntuple<T,DIM> operator/(const T& r)const;
				
    inline ntuple<T,DIM> mod(const T& r)const;
								
    ntuple<T,DIM>& operator+=(const ntuple<T,DIM>& other);
		
    ntuple<T,DIM>& operator-=(const ntuple<T,DIM>& other);

    ntuple<T,DIM>& operator*=(const T& r);

    ntuple<T,DIM>& operator/=(const T& r);	

    // set all elements to scalar value:
    // (implementation note: default assigment op (i.e. ntuple& operator=(const ntuple& other)) is automatically generated by compiler)
    ntuple<T,DIM>& operator=(const T& r);
    
    ntuple<T,DIM>& mod_assign(const T& r);	
		
		T dot(const ntuple<T,DIM>& other)const;
		
		template <class S> // intended for numberTraits<T>::magnitudeType
		T dot(const ntuple<S, DIM>& other)const;
		
		ntuple<T,DIM> cross(const ntuple<T,DIM>& other)const;
		
		template <class S> // intended for numberTraits<T>::magnitudeType
		ntuple<T,DIM> cross(const ntuple<S,DIM>& other)const;
		
		/*
     * static ntuple<T,DIM> unit()
     *   ntuple of unit vector (i.e. normalized ntuple, _not_ ntuple with unit elements)
     */
    static ntuple<T,DIM> unit(void);

		/*
     * static ntuple<T,DIM> filled(const T& t)
     *   ntuple with constant elements)
     */
		static ntuple<T,DIM> filled(const T& t);
    

		// sort elements into ascending order:
		static void sort(ntuple<T,DIM>& p);

    #if 0 // --------------------------- obsolete: use linalgUtil.h: "argsort" ------------------------------------
		// indices vn into ntuple p with values in ascending order:
		static void index_sort(const ntuple<T,DIM>& p, ntuple<size_t,DIM>& vn);
    #endif // -----------------------------------------------------------------------------------------------------

    static void apply( T (*func)(const T&), const ntuple<T,DIM>& src, ntuple<T,DIM>& dest);
		
    bool writeBinary(abstractCommHandle *fp)const;
		
		bool readBinary(abstractCommHandle *fp);
    
		size_t binarySize(void);

    
		void write(std::ostream& os)const;
		
		void read(std::istream& is);
    
		void debug_print(void)const;
		
		ntuple(bool clear=true);
		
		// allow use in gmm generic abstract_vector codes, (note: error if DIM_ != DIM)
		ntuple(size_t DIM_);
		
		ntuple(const T& e1);
	
		ntuple(const T& e1, const T& e2);

    ntuple(const T& e1, const T& e2, const T& e3);
		
    #if !defined(__ICC) && !defined(__PGI)
    template <class T1>
    ntuple(const T1& e1, const T1& e2, const T1& e3);
    #else
    template <class T1>
    ntuple(const T1& e1, const T1& e2, const T1& e3)    
    {
     assert(DIM >= 3);
     conv(v_[0],e1);
     conv(v_[1],e2);
     conv(v_[2],e3);
     for(size_t n=3; n<DIM; ++n)
	     v_[n] = zero<T>();
    }
    #endif									
}; // class ntuple

template <class T, size_t DIM>
inline ntuple<T,DIM> operator*(const T& r, const ntuple<T,DIM>& p);

template <class T, size_t DIM>
inline typename numberTraits<T>::magnitudeType dist(const ntuple<T,DIM>& p1, const ntuple<T,DIM>& p2);

template <class T, size_t DIM>		
inline typename numberTraits<T>::magnitudeType absSqr(const ntuple<T,DIM>& p);

template <class T, size_t DIM>		
inline size_t numberNonzeroElements(const ntuple<T,DIM>& p, const T& eps=epsilon<T>());

template <class T, size_t DIM>
inline bool isZero(const ntuple<T,DIM>& p, const T& eps=epsilon<T>());

template <class T, size_t DIM>
inline bool isNAN(const ntuple<T,DIM>& p);

// in analogy to std::min_element returning an iterator, these methods return indices:
template <class T, size_t DIM>
inline size_t min_element(const ntuple<T,DIM>& p);

template <class T, size_t DIM>
inline size_t max_element(const ntuple<T,DIM>& p);

// sort elements into ascending order:
template <class T, size_t DIM>
inline void sort(ntuple<T,DIM>& p);

// indices vn into ntuple p with values in ascending order:
template <class T, size_t DIM>
inline void index_sort(const ntuple<T,DIM>& p, ntuple<size_t,DIM>& vn);

template <class T1, class T2, size_t DIM>
inline void conv(ntuple<T1,DIM>& dest, const ntuple<T2,DIM>& src);

template <class T, size_t DIM>
inline bool writeBinary(abstractCommHandle *fp, const ntuple<T,DIM>& p);

template <class T, size_t DIM>
inline bool readBinary(abstractCommHandle *fp, ntuple<T,DIM>& p);

template <class T, size_t DIM>
inline std::ostream& operator<<(std::ostream& os, const ntuple<T,DIM>& p);

template <class T, size_t DIM>
inline std::istream& operator>>(std::istream& is, ntuple<T,DIM>& p);


// interval class for ntuple:
template <class T, size_t DIM>
class ntuple_interval{
    ntuple<T,DIM> start_, end_;
    T left_epsilon_, right_epsilon_;
  public:

    const ntuple<T,DIM>& start(void)const;
    ntuple<T,DIM>& start(void);

    const ntuple<T,DIM>& end(void)const;
    ntuple<T,DIM>& end(void);
    
    const T& left_epsilon(void)const;
    const T& right_epsilon(void)const;
    
    // test if point p is contained in associated set:
    bool interior(const ntuple<T,DIM>& p)const;
    bool boundary(const ntuple<T,DIM>& p)const;
    bool exterior(const ntuple<T,DIM>& p)const;
    bool closure(const ntuple<T,DIM>& p)const;
    bool left_closure(const ntuple<T,DIM>& p)const;
    bool right_closure(const ntuple<T,DIM>& p)const;


    bool operator==(const ntuple_interval<T,DIM>& other)const;
    
    bool operator!=(const ntuple_interval<T,DIM>& other)const;


    bool writeBinary(abstractCommHandle *fp)const;
    bool readBinary(abstractCommHandle *fp);
    size_t binarySize(void)const;

    
    void write(std::ostream& os, const ntuple<T,DIM>*p=NULL)const;

    #if !defined(__PGI) && !defined(__INTEL_COMPILER)

    /**
     * @brief  Calculate scale tuple corresponding to this ntuple-interval (i.e. as end() - start()).
     */
     inline ntuple<T,DIM> scale(void)const;
     
    /**
      * @brief Calculate extent of a container of ntuple<T,DIM> as ntuple_interval<T,DIM>
      * Assumes typename U::value_type is ntuple<T,DIM>
      */
    template <class U>
    static ntuple_interval extent(const U& u, const T& left_eps, const T& right_eps);

    /**
      * @brief Calculate extent of a container of ntuple<T,DIM> as ntuple_interval<T,DIM>
      * Assumes typename U::value_type is ntuple<T,DIM>
      *   (this signature assumes left_epsilon == right_epsilon)
      */
    template <class U>
    inline static ntuple_interval extent(const U& u, const T& eps=zero<T>());

    #else
    // PGI and INTEL require body definition at point of primary declaration for template method of template class:

    /**
      * @brief Calculate extent of a container of ntuple<T,DIM> as ntuple_interval<T,DIM>
      * Assumes typename U::value_type is ntuple<T,DIM>
      */
    template <class U>
    static ntuple_interval extent(const U& u, const T& left_eps, const T& right_eps)
    {
      // empty container has zero extent:
      ntuple_interval val(ntuple<T,DIM>(true), ntuple<T,DIM>(true), left_eps, right_eps);
      
      if (!u.empty()){
        val.start() = *u.begin();
        val.end() = *u.begin();
        for(typename U::const_iterator itU = u.begin(), itUEnd = u.end();
            itU != itUEnd;
            ++itU)
        for(size_t n = 0; n < DIM; ++n){
          const T& test((*itU)[n]);
          if (test < val.start[n])
            val.start[n] = test;
          if (test > val.end[n])
            val.end[n] = test;
        }
      }
      
      return val;
    }
    
    /**
      * @brief Calculate extent of a container of ntuple<T,DIM> as ntuple_interval<T,DIM>
      * Assumes typename U::value_type is ntuple<T,DIM>
      *   (this signature assumes left_epsilon == right_epsilon)
      */
    template <class U>
    inline static ntuple_interval extent(const U& u, const T& eps=zero<T>())
    { return ntuple_interval<T,DIM>::template extent<U>(u, eps, eps); }
        
    #endif
    
    ntuple_interval(const ntuple<T,DIM>& start, const ntuple<T,DIM>& end, const T& left_eps, const T& right_eps);         
    
    //! this signature assumes left_eps == right_eps:
    ntuple_interval(const ntuple<T,DIM>& start, const ntuple<T,DIM>& end, const T& eps=zero<T>());         

    ntuple_interval(void);         
};  // class ntuple_interval


template <class T, size_t DIM>
inline bool writeBinary(abstractCommHandle *fp, const ntuple_interval<T,DIM>& p);

template <class T, size_t DIM>
inline bool readBinary(abstractCommHandle *fp, ntuple_interval<T,DIM>& p);

template <class T, size_t DIM>
inline std::ostream& operator<<(std::ostream& os, const ntuple_interval<T,DIM>& p);

} // namespace linalg


//! @cond full_docs
// Insert HASH functions for ntuple into the appropriate namespace
namespace _STL_EXT_NAMESPACE_{

// a unique hash for elements with values up to (1U<<(UBITS/DIM) - 1):
// NOTE: if this is ever actually used for mere::R, make a specialization: this is intended as a _sketch_.
template <class T, size_t DIM>
struct hash<  linalg::ntuple<T,DIM> >{
  inline size_t operator()(const linalg::ntuple<T,DIM>& p)const
  {
	 using number::zero;
	 using number::one;
	 using number::integer;
	 using number::pow_n;
	 using number::conv;
	 
	 throw std::runtime_error("hash< ntuple<T,DIM> >::operator(): this generic method should not be used!");
	 const size_t UBITS(sizeof(size_t)*8);
   size_t rval(0);
	 T rval_(zero<T>());
	 const T fieldShift(integer<T>(1U<<(UBITS/DIM))),
	   fieldMax(fieldShift-one<T>());
	 for(size_t n = 0; n < DIM; ++n){	   
		 T r(p[n]/log10(p[n]));
		 r /= integer<T>(10); // r \in [0,1]
		 r *= fieldMax;
		 rval_ += r*pow_n(fieldShift, n);
	 }
	 conv(rval,rval_);
	 return rval;
  } 
};

// a unique hash for elements with values up to (1U<<(UBITS/DIM) - 1):
template <>
inline size_t hash< linalg::ntuple<long,3> >::operator()(const linalg::ntuple<long,3>& p)const
{
 const size_t DIM(3);
 const size_t UBITS(sizeof(size_t)*8);
 size_t rval(0);
 const size_t fieldMax( (1U<<(UBITS/DIM)) - 1 );
 for(size_t n = 0; n < DIM; ++n){
   // non-offset bits, as opposed to the numerical cast,
	 //   otherwise positive and negative are not distinct:	   
	 const size_t &r(*reinterpret_cast<const size_t*>(&(p[n])));   
	 rval += (r&fieldMax) * ( 1U<<( (UBITS/DIM)*n ) ); // 2^(UBITS/DIM) distinct values, for each dimension.
 }
 return rval;
} 

} // namespace _STL_EXT_NAMESPACE_
///< @endcond

#if defined(GMM_DEF_H__)
// interface to gmm:
namespace gmm{

  template <class T, size_t DIM>
  struct linalg_traits< linalg::ntuple<T,DIM> > {
    typedef linalg::ntuple<T,DIM> this_type;
    typedef this_type origin_type;
    typedef linalg_false is_reference;
    typedef abstract_vector linalg_type;
    typedef T value_type;
    typedef T& reference;
    typedef typename this_type::iterator iterator;
    typedef typename this_type::const_iterator const_iterator;
    typedef abstract_dense storage_type;
    typedef linalg_true index_sorted;
    static size_type size(const this_type &v) { return v.size(); }
    static iterator begin(this_type &v) { return v.begin(); }
    static const_iterator begin(const this_type &v) { return v.begin(); }
    static iterator end(this_type &v) { return v.end(); }
    static const_iterator end(const this_type &v) { return v.end(); }
    static origin_type* origin(this_type &v) { return &v; }
    static const origin_type* origin(const this_type &v) { return &v; }
    static void clear(origin_type*, const iterator &it, const iterator &ite)
    { std::fill(it, ite, number_traits<T>::zero() ); }
    static void do_clear(this_type &v) { std::fill(v.begin(), v.end(), number_traits<T>::zero() ); }
    static value_type access(const origin_type *, const const_iterator &it,
			     const const_iterator &, size_type i)
    { return it[i]; }
    static reference access(origin_type *, const iterator &it,
			    const iterator &, size_type i)
    { return it[i]; }
    static void resize(this_type &v, size_type n) { v.resize(n); }
  };

} // namespace gmm
#endif

namespace linalg{

/**
 * @brief Traits class to facilitate implementation of N-dimensional arrays and container objects
 *    with either scalar (RANK = 0) or non-scalar (RANK > 0) elements.
 */
template <class T>
struct tensor_traits{
  static const size_t rank = 0;
  static const size_t N_components = 1;
  typedef T scalar_type;
}; 

template <class T, size_t NDIM>
struct tensor_traits<linalg::ntuple<T,NDIM> >{
  static const size_t rank = 1;
  static const size_t N_components = NDIM;
  typedef T scalar_type;
};

} // namespace linalg


#include "ntuple_template.h"

#endif // __ntuple__h
